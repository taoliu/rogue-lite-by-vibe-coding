<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RogueLite</title>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #121722;
      --accent: #77e6b6;
      --muted: #9aa4b2;
      --danger: #ff6b6b;
      --gold: #ffd166;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: #e6edf3; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; }
    .wrap { display: grid; grid-template-columns: 1fr 320px; gap: 12px; max-width: 1200px; margin: 10px auto; padding: 0 10px; }
    #view { background: #0a0d12; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.4); width: 100%; aspect-ratio: 4/3; image-rendering: pixelated; }
    .side { background: var(--panel); border-radius: 12px; padding: 12px; display: grid; grid-template-rows: auto auto 1fr auto; gap: 10px; }
    h1 { font-size: 18px; margin: 0 0 4px; color: var(--accent); }
    .row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .badge { padding: 2px 6px; border-radius: 6px; background: #1a2233; color: #c9d4e3; }
    .red { color: var(--danger); }
    .gold { color: var(--gold); }
    .muted { color: var(--muted); }
    .log { background: #0e1420; border-radius: 10px; padding: 8px; height: 140px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .inv { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
    .inv .slot { background: #0e1420; border: 1px solid #1b2538; border-radius: 8px; padding: 6px; min-height: 56px; display: grid; place-items: center; text-align: center; }
    .controls { background: #0e1420; border-radius: 10px; padding: 8px; font-size: 12px; color: var(--muted); }
    button, select { background: #152038; border: 1px solid #253659; color: #e6edf3; padding: 6px 10px; border-radius: 8px; cursor: pointer; }
    button:hover { filter: brightness(1.1); }
    .topbar { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .statline { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .bar { height: 8px; background: #182033; border-radius: 5px; overflow: hidden; }
    .bar > i { display: block; height: 100%; background: linear-gradient(90deg, #2dd4bf, #34d399); }
    .bar.hp > i { background: linear-gradient(90deg, #ef4444, #f97316); }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,.7); display: grid; place-items: center; }
    .card { width: min(540px, 92vw); background: #0f1522; border: 1px solid #1f2a44; border-radius: 14px; padding: 16px; box-shadow: 0 25px 60px rgba(0,0,0,.5); }
    .grid3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px; }
    .classbtn { text-align: left; }
    .classbtn h3 { margin: 4px 0; font-size: 16px; color: var(--accent); }
    .classbtn p { margin: 0; font-size: 12px; color: var(--muted); }
    .seed { width: 130px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="view" width="960" height="720"></canvas>
    <aside class="side">
      <div class="topbar">
        <h1>RogueLite</h1>
        <div class="row">
          <button id="btnRestart">New Run</button>
          <button id="btnHelp">Help</button>
        </div>
      </div>
      <div class="statline">
        <div>
          <div class="row"><span class="badge">Class</span><span id="uiClass">‚Äî</span></div>
          <div class="row"><span class="badge">Lvl</span><span id="uiLvl">1</span><span class="badge">XP</span><span id="uiXP">0</span></div>
          <div class="row"><span class="badge">ATK</span><span id="uiAtk">0</span><span class="badge">DEF</span><span id="uiDef">0</span></div>
        </div>
        <div>
          <div class="row"><span class="badge">HP</span><span id="uiHP">0/0</span></div>
          <div class="bar hp"><i id="barHP" style="width:100%"></i></div>
          <div class="row"><span class="badge">Mana</span><span id="uiMP">0/0</span></div>
          <div class="bar"><i id="barMP" style="width:100%"></i></div>
        </div>
      </div>
      <div>
        <div class="row"><span class="badge gold">Gold</span><span id="uiGold">0</span><span class="badge">Floor</span><span id="uiFloor">1</span></div>
      </div>
      <div>
        <div class="row"><span class="badge">Inventory</span></div>
        <div class="inv" id="uiInv"></div>
      </div>
      <div>
        <div class="row"><span class="badge">Log</span></div>
        <div class="log" id="uiLog"></div>
      </div>
      <div class="controls">
        <b>Controls</b><br/>
        Move: WASD / Arrow keys ¬∑ Wait: . (period) ¬∑ Attack: F (melee) ¬∑ Ability: Space (class skill) ¬∑ Pick up: G ¬∑ Descend stairs: &gt; <br/>
        Warrior ability: Whirlwind (hit all adjacent) ¬∑ Mage: Fireball (AoE, 2x2) ¬∑ Hunter: Shoot arrow (range 5)
      </div>
    </aside>
  </div>

  <!-- Class select modal -->
  <div class="modal" id="classModal">
    <div class="card">
      <h2>Choose Your Class</h2>
      <div class="row">
        <label>Seed <input id="seed" class="seed" placeholder="random"/></label>
      </div>
      <div class="grid3">
        <button class="classbtn" data-class="warrior">
          <h3>‚öîÔ∏è Warrior</h3>
          <p>High HP &amp; melee damage. Ability: Whirlwind around you.</p>
        </button>
        <button class="classbtn" data-class="mage">
          <h3>‚ú® Mage</h3>
          <p>Low HP, high mana. Ability: Fireball 2x2 blast.</p>
        </button>
        <button class="classbtn" data-class="hunter">
          <h3>üèπ Hunter</h3>
          <p>Balanced. Ability: Shoot arrow up to 5 tiles.</p>
        </button>
      </div>
    </div>
  </div>

  <script>
  // --- Utility RNG (seeded) ---
  function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0}}
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
  function rngFromSeed(seed){ if(!seed) seed = Math.random().toString(36).slice(2); const s = xmur3(seed); return {rand: mulberry32(s()), seed}; }

  const T = { WALL: 1, FLOOR: 0, STAIRS: 2, CHEST: 3 };
  const TILE_SIZE = 24; // pixels per tile
  const MAP_W = 40, MAP_H = 30; // 40x30 -> 960x720 canvas

  // Monsters (D&D-ish)
  const MONSTERS = [
    {name:'Goblin', ch:'g', hp:6, atk:2, xp:4},
    {name:'Skeleton', ch:'s', hp:8, atk:3, xp:6},
    {name:'Orc', ch:'o', hp:12, atk:4, xp:10},
    {name:'Zombie', ch:'z', hp:14, atk:3, xp:10},
    {name:'Mimic', ch:'m', hp:10, atk:5, xp:12},
    {name:'Ogre', ch:'O', hp:18, atk:6, xp:18},
    {name:'Young Dragon', ch:'D', hp:28, atk:8, xp:30}
  ];

  const LOOT = {
    common: [
      {name:'Potion of Healing', type:'potion', heal:10},
      {name:'Throwing Dagger', type:'throw', dmg:5},
      {name:'Mana Vial', type:'mana', mana:8},
      {name:'Bomb', type:'bomb', dmg:8}
    ],
    rare: [
      {name:'Sword +1', type:'equip', atk:+1},
      {name:'Staff +1', type:'equip', atk:+1, mp:+4},
      {name:'Leather Armor', type:'equip', def:+1},
      {name:'Ring of Vigor', type:'equip', hp:+5}
    ]
  };

  const CLASSES = {
    warrior: { hp: 30, mp: 0, atk: 5, def: 2, abilityCd: 5 },
    mage:    { hp: 18, mp: 20, atk: 2, def: 1, abilityCd: 5 },
    hunter:  { hp: 24, mp: 8,  atk: 3, def: 1, abilityCd: 4 }
  };

  // --- Game State ---
  const G = {
    rng: rngFromSeed(),
    map: [],
    seen: [], // fog of war
    entities: [], // monsters
    items: [], // loose items on ground
    player: null,
    floor: 1,
    turn: 0,
    cooldown: 0,
    gold: 0,
    messages: []
  };

  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  function log(msg){
    G.messages.unshift(msg);
    const el = document.getElementById('uiLog');
    el.innerHTML = G.messages.slice(0,10).map(x=>`‚ñ∂ ${x}`).join('<br>');
    el.scrollTop = 0;
  }

  function between(v,min,max){return v>=min && v<=max}

  // --- Map generation: drunkard walk rooms + sprinkled walls ---
  function genMap() {
    const {rand} = G.rng;
    const w=MAP_W,h=MAP_H;
    const map = Array.from({length:h},()=>Array(w).fill(T.WALL));
    const seen= Array.from({length:h},()=>Array(w).fill(false));

    // open up with random walk
    let x = (w/2)|0, y = (h/2)|0; map[y][x]=T.FLOOR;
    let floors = 1, target = (w*h*0.45)|0; // carve ~45% floors
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(floors<target){
      const [dx,dy]=dirs[(rand()*4)|0];
      x = Math.max(1, Math.min(w-2, x+dx));
      y = Math.max(1, Math.min(h-2, y+dy));
      if(map[y][x]===T.WALL){ map[y][x]=T.FLOOR; floors++; }
      // occasionally carve neighbors to make rooms
      if(rand()<0.18){
        for(const [ax,ay] of dirs){
          const nx=x+ax, ny=y+ay; if(nx>1&&ny>1&&nx<w-2&&ny<h-2){ map[ny][nx]=T.FLOOR; }
        }
      }
    }

    // place stairs far from center
    let sx=0, sy=0, tries=0;
    do { sx=(rand()*w)|0; sy=(rand()*h)|0; tries++; } while((map[sy][sx]!==T.FLOOR || Math.hypot(sx-w/2, sy-h/2)<Math.min(w,h)/3) && tries<5e3);
    map[sy][sx]=T.STAIRS;

    // sprinkle chests
    for(let i=0;i<10;i++){
      const cx=(rand()*w)|0, cy=(rand()*h)|0; if(map[cy][cx]===T.FLOOR) map[cy][cx]=T.CHEST;
    }

    G.map = map; G.seen = seen;

    // place monsters
    G.entities=[];
    const monsCount = 10 + (G.floor*2);
    let placed=0; let safety=0;
    while(placed<monsCount && safety<5000){
      safety++;
      const mx=(rand()*w)|0, my=(rand()*h)|0; if(map[my][mx]!==T.FLOOR) continue;
      // avoid center spawn area (for player)
      if(Math.hypot(mx-w/2,my-h/2) < 6) continue;
      const tier = Math.min(MONSTERS.length-1, 2 + ((rand()*G.floor)|0));
      const base = MONSTERS[(rand()*(tier+1))|0];
      G.entities.push({type:'monster', x:mx, y:my, ...JSON.parse(JSON.stringify(base)), hpMax: base.hp});
      placed++;
    }

    // scatter ground items
    G.items=[];
    for(let i=0;i<6;i++) placeGroundItem();

    // position player near center
    let px=(w/2)|0, py=(h/2)|0; while(map[py][px]!==T.FLOOR){ px++; }
    G.player.x=px; G.player.y=py;
    fov();
  }

  function placeGroundItem(){
    const {rand}=G.rng, w=MAP_W, h=MAP_H;
    let ix=0, iy=0, tries=0;
    do{ ix=(rand()*w)|0; iy=(rand()*h)|0; tries++; } while(G.map[iy][ix]!==T.FLOOR && tries<1000);
    const isRare = Math.random()<0.25;
    const pool = isRare? LOOT.rare : LOOT.common;
    const item = JSON.parse(JSON.stringify(pool[(Math.random()*pool.length)|0]));
    G.items.push({x:ix, y:iy, item});
  }

  // --- Player setup and inventory ---
  function newPlayer(cls){
    const base = CLASSES[cls];
    return {
      type:'player', cls, x:0, y:0,
      hp: base.hp, hpMax: base.hp,
      mp: base.mp, mpMax: base.mp,
      atk: base.atk, def: base.def,
      lvl: 1, xp: 0, nextXp: 20,
      abilityCd: 0, abilityMaxCd: base.abilityCd,
      inv: [],
      weapon: null, armor: null
    }
  }

  function gainXP(x){
    G.player.xp += x; log(`You gain ${x} XP.`);
    while(G.player.xp >= G.player.nextXp){
      G.player.xp -= G.player.nextXp; G.player.lvl++; G.player.nextXp = Math.floor(G.player.nextXp*1.5);
      G.player.hpMax += 5; G.player.atk += 1; G.player.hp = G.player.hpMax;
      log(`== Level up! You are now level ${G.player.lvl}.`);
    }
  }

  function pickup(){
    const here = G.items.findIndex(it=>it.x===G.player.x && it.y===G.player.y);
    if(here===-1){ log('Nothing to pick up.'); return; }
    const obj = G.items.splice(here,1)[0].item;
    G.player.inv.push(obj);
    log(`Picked up ${obj.name}.`);
    renderInv();
  }

  function useItem(i){
    const it = G.player.inv[i]; if(!it) return;
    if(it.type==='potion'){ G.player.hp = Math.min(G.player.hpMax, G.player.hp + it.heal); log(`You drink a potion (+${it.heal} HP).`); G.player.inv.splice(i,1); }
    else if(it.type==='mana'){ G.player.mp = Math.min(G.player.mpMax, G.player.mp + (it.mana||5)); log(`Mana restored.`); G.player.inv.splice(i,1); }
    else if(it.type==='bomb'){ log('You throw a bomb!'); aoe(G.player.x, G.player.y, 1, it.dmg); G.player.inv.splice(i,1); tick(); }
    else if(it.type==='throw'){ log('You throw a dagger!'); shootLine(it.dmg, 4); G.player.inv.splice(i,1); tick(); }
    else if(it.type==='equip'){
      if(it.hp) G.player.hpMax += it.hp;
      if(it.mp) G.player.mpMax += it.mp;
      if(it.atk) G.player.atk += it.atk;
      if(it.def) G.player.def += it.def;
      log(`Equipped ${it.name}.`); G.player.inv.splice(i,1);
    }
    updateUI();
  }

  // --- Field of View (simple LOS radius) ---
  function fov(){
    const r=8; const {x:px,y:py}=G.player;
    for(let y=py-r;y<=py+r;y++) for(let x=px-r;x<=px+r;x++){
      if(!between(x,0,MAP_W-1)||!between(y,0,MAP_H-1)) continue;
      if(Math.hypot(x-px,y-py)<=r){ G.seen[y][x]=true; }
    }
  }

  // --- Movement & Combat ---
  function isWalkable(x,y){ return between(x,0,MAP_W-1) && between(y,0,MAP_H-1) && G.map[y][x]!==T.WALL; }
  function entityAt(x,y){ return G.entities.find(e=>e.x===x&&e.y===y); }

  function move(dx,dy){
    const nx=G.player.x+dx, ny=G.player.y+dy;
    if(!isWalkable(nx,ny)){ log('You bump into a wall.'); return; }
    const m = entityAt(nx,ny);
    if(m){
      // attack melee
      const dmg = Math.max(1, G.player.atk - (m.def||0));
      m.hp -= dmg; log(`You hit the ${m.name} for ${dmg}.`);
      if(m.hp<=0){
        log(`The ${m.name} dies.`);
        gainXP(m.xp);
        maybeDrop(m);
        G.entities = G.entities.filter(e=>e!==m);
      }
      tick();
      return;
    }
    G.player.x=nx; G.player.y=ny; tick();
  }

  function wait(){ log('You wait.'); tick(); }

  function maybeDrop(mon){
    // gold or item
    if(Math.random()<0.7){ const g = (Math.random()*8+2)|0; G.gold+=g; log(`You loot ${g} gold.`); }
    if(Math.random()<0.35){ G.items.push({x:mon.x, y:mon.y, item: JSON.parse(JSON.stringify(LOOT.common[(Math.random()*LOOT.common.length)|0]))}); }
    if(Math.random()<0.12){ G.items.push({x:mon.x, y:mon.y, item: JSON.parse(JSON.stringify(LOOT.rare[(Math.random()*LOOT.rare.length)|0]))}); }
    updateUI();
  }

  // Ability handlers
  function ability(){
    if(G.player.abilityCd>0){ log(`Ability on cooldown (${G.player.abilityCd}).`); return; }
    if(G.player.cls==='warrior'){
      log('Whirlwind!');
      const tiles=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      for(const [dx,dy] of tiles){ const m=entityAt(G.player.x+dx, G.player.y+dy); if(m){ const dmg = Math.max(1, G.player.atk+1-(m.def||0)); m.hp-=dmg; log(`Whirlwind hits ${m.name} for ${dmg}.`); if(m.hp<=0){ gainXP(m.xp); maybeDrop(m); G.entities=G.entities.filter(e=>e!==m);} } }
      G.player.abilityCd = G.player.abilityMaxCd;
      tick();
    } else if(G.player.cls==='mage'){
      if(G.player.mp<6){ log('Not enough mana.'); return; }
      log('Fireball!');
      G.player.mp-=6; updateUI();
      // blast 2x2 centered one tile ahead in facing direction (use last move dir or default up)
      aoe(G.player.x, G.player.y, 1, 7);
      G.player.abilityCd = G.player.abilityMaxCd; tick();
    } else if(G.player.cls==='hunter'){
      log('You shoot an arrow.');
      shootLine(G.player.atk+2, 5);
      G.player.abilityCd = G.player.abilityMaxCd; tick();
    }
  }

  function aoe(cx,cy,r,dmg){
    for(const e of [...G.entities]){
      if(Math.hypot(e.x-cx,e.y-cy)<=r){ e.hp-=dmg; log(`${e.name} takes ${dmg} damage.`); if(e.hp<=0){ gainXP(e.xp); maybeDrop(e); G.entities=G.entities.filter(x=>x!==e); } }
    }
  }

  function shootLine(dmg, range){
    // shoot in the direction of last input; store lastDir
    const dir = G.lastDir || [0,-1];
    let [x,y]=[G.player.x, G.player.y];
    for(let i=0;i<range;i++){
      x+=dir[0]; y+=dir[1]; if(!isWalkable(x,y)) break; const m=entityAt(x,y); if(m){ m.hp-=dmg; log(`Arrow hits ${m.name} for ${dmg}.`); if(m.hp<=0){ gainXP(m.xp); maybeDrop(m); G.entities=G.entities.filter(e=>e!==m);} break; }
    }
  }

  function descend(){
    if(G.map[G.player.y][G.player.x]!==T.STAIRS){ log('No stairs here.'); return; }
    G.floor++; log(`You descend to floor ${G.floor}.`);
    genMap(); updateUI();
  }

  function enemyTurn(){
    for(const m of G.entities){
      // very simple AI: approach player if in sight (within radius), else wander
      const dx = G.player.x - m.x; const dy = G.player.y - m.y; const dist = Math.hypot(dx,dy);
      if(dist<7){
        const sdx = Math.sign(dx), sdy = Math.sign(dy);
        const nx = m.x + (Math.abs(dx)>Math.abs(dy)? sdx : 0);
        const ny = m.y + (Math.abs(dy)>=Math.abs(dx)? sdy : 0);
        if(nx===G.player.x && ny===G.player.y){
          const dmg = Math.max(1, (m.atk||2) - G.player.def);
          G.player.hp -= dmg; log(`${m.name} hits you for ${dmg}.`);
          if(G.player.hp<=0){ gameOver(); return; }
        } else if(isWalkable(nx,ny) && !entityAt(nx,ny)) { m.x=nx; m.y=ny; }
      } else if(Math.random()<0.3){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; const [ax,ay]=dirs[(Math.random()*4)|0];
        const nx=m.x+ax, ny=m.y+ay; if(isWalkable(nx,ny) && !entityAt(nx,ny)) { m.x=nx; m.y=ny; }
      }
    }
  }

  function tick(){
    G.turn++;
    if(G.player.abilityCd>0) G.player.abilityCd--;
    enemyTurn();
    fov();
    updateUI();
    render();
  }

  function gameOver(){
    log('*** You died. Press "New Run" to try again.');
    window.removeEventListener('keydown', onKey);
  }

  // --- Rendering ---
  function rect(x,y,w,h,col){ ctx.fillStyle=col; ctx.fillRect(x,y,w,h); }
  function drawTile(x,y,t){
    const px=x*TILE_SIZE, py=y*TILE_SIZE;
    if(t===T.WALL) rect(px,py,TILE_SIZE,TILE_SIZE,'#1a2336');
    else if(t===T.FLOOR) rect(px,py,TILE_SIZE,TILE_SIZE,'#0f1522');
    else if(t===T.STAIRS){ rect(px,py,TILE_SIZE,TILE_SIZE,'#0f1522'); ctx.fillStyle='#b8c1ff'; ctx.fillRect(px+8,py+8,8,8); }
    else if(t===T.CHEST){ rect(px,py,TILE_SIZE,TILE_SIZE,'#0f1522'); ctx.fillStyle='#8b5e34'; ctx.fillRect(px+5,py+6,14,12); ctx.fillStyle='#d4af37'; ctx.fillRect(px+5,py+12,14,2); }
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // tiles
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
      const seen = G.seen[y][x];
      if(!seen){ rect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE,'#07090f'); continue; }
      drawTile(x,y,G.map[y][x]);
    }
    // items
    for(const it of G.items){ if(!G.seen[it.y][it.x]) continue; ctx.fillStyle = '#ffd166'; ctx.fillRect(it.x*TILE_SIZE+10, it.y*TILE_SIZE+10, 4,4); }
    // entities
    for(const e of G.entities){ if(!G.seen[e.y][e.x]) continue; ctx.fillStyle='#76e6ff'; ctx.fillRect(e.x*TILE_SIZE+6,e.y*TILE_SIZE+6,12,12); ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.fillText(e.ch, e.x*TILE_SIZE+8, e.y*TILE_SIZE+16); }
    // player
    ctx.fillStyle = '#2dd4bf'; ctx.fillRect(G.player.x*TILE_SIZE+6, G.player.y*TILE_SIZE+6, 12, 12);
  }

  // UI
  function renderInv(){
    const inv = document.getElementById('uiInv');
    inv.innerHTML = '';
    G.player.inv.forEach((it, idx)=>{
      const div = document.createElement('div');
      div.className = 'slot';
      div.innerHTML = `<b>${it.name}</b><br><span class="muted">[${idx+1}] use</span>`;
      div.addEventListener('click', ()=>useItem(idx));
      inv.appendChild(div);
    });
    // pad to 6 slots
    for(let i=G.player.inv.length;i<6;i++){ const d=document.createElement('div'); d.className='slot'; d.innerHTML='‚Äî'; inv.appendChild(d); }
  }

  function updateUI(){
    document.getElementById('uiClass').textContent = G.player.cls;
    document.getElementById('uiLvl').textContent = G.player.lvl;
    document.getElementById('uiXP').textContent = `${G.player.xp}/${G.player.nextXp}`;
    document.getElementById('uiAtk').textContent = G.player.atk;
    document.getElementById('uiDef').textContent = G.player.def;
    document.getElementById('uiHP').textContent = `${G.player.hp}/${G.player.hpMax}`;
    document.getElementById('uiMP').textContent = `${G.player.mp}/${G.player.mpMax}`;
    document.getElementById('uiGold').textContent = G.gold;
    document.getElementById('uiFloor').textContent = G.floor;
    document.getElementById('barHP').style.width = `${Math.max(0, (G.player.hp/G.player.hpMax)*100)}%`;
    document.getElementById('barMP').style.width = `${G.player.mpMax? (G.player.mp/G.player.mpMax)*100 : 0}%`;
    renderInv();
  }

  // Input
  function onKey(e){
    const k=e.key.toLowerCase();
    if(['arrowup','w'].includes(k)){ move(0,-1); G.lastDir=[0,-1]; }
    else if(['arrowdown','s'].includes(k)){ move(0,1); G.lastDir=[0,1]; }
    else if(['arrowleft','a'].includes(k)){ move(-1,0); G.lastDir=[-1,0]; }
    else if(['arrowright','d'].includes(k)){ move(1,0); G.lastDir=[1,0]; }
    else if(k==='f'){ // melee in facing dir
      const d=G.lastDir||[0,-1]; const m=entityAt(G.player.x+d[0], G.player.y+d[1]); if(m){ const dmg=Math.max(1, G.player.atk-(m.def||0)); m.hp-=dmg; log(`You strike the ${m.name} for ${dmg}.`); if(m.hp<=0){ gainXP(m.xp); maybeDrop(m); G.entities=G.entities.filter(e=>e!==m);} tick(); } else log('No enemy to strike.');
    }
    else if(k==='.' || k==='5') wait();
    else if(k===' '){ e.preventDefault(); ability(); }
    else if(k==='g'){ pickup(); }
    else if(k==='>'){ descend(); }
    else if(k>='1'&&k<='9'){ useItem(parseInt(k)-1); }
  }

  // Bootstrap
  function startRun(cls){
    const seedStr = document.getElementById('seed').value.trim();
    G.rng = rngFromSeed(seedStr || undefined);
    G.player = newPlayer(cls);
    G.floor=1; G.turn=0; G.gold=0; G.messages=[]; G.lastDir=[0,-1];
    genMap(); updateUI(); render();
    document.getElementById('classModal').style.display='none';
    window.addEventListener('keydown', onKey);
    log(`You enter the dungeon as a ${cls}. Seed: ${G.rng.seed}`);
  }

  document.getElementById('btnRestart').addEventListener('click', ()=>{
    document.getElementById('classModal').style.display='grid';
    window.removeEventListener('keydown', onKey);
  });
  document.getElementById('btnHelp').addEventListener('click', ()=>{
    alert('Move: WASD/Arrows | Wait: . | Attack: F | Ability: Space | Pick up: G | Down stairs: >\nInventory: click item or press 1..9');
  });
  for(const b of document.querySelectorAll('.classbtn')){
    b.addEventListener('click', ()=> startRun(b.dataset.class));
  }

  // Start paused at class select
  updateUI();
  render();
  </script>
</body>
</html>
